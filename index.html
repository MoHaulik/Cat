<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WebXR AR Ghost Cat with Sound</title>
    <style>
      /* Remove scrollbars and ensure the canvas fills the screen */
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <!-- Your entire app will be rendered on this page -->
    <script type="module">
      import * as THREE from 'https://cdn.skypack.dev/three@0.150.1';
      import { ARButton } from 'https://cdn.skypack.dev/three@0.150.1/examples/jsm/webxr/ARButton.js';

      let camera, scene, renderer;
      let cube, reticle, sound;

      init();
      window.addEventListener('resize', onWindowResize, false);

      function init() {
        // Create a new scene
        scene = new THREE.Scene();

        // Set up the camera with a 70Â° field-of-view,
        // adapting to the current window dimensions,
        // with near (0.01) and far (20) clipping planes.
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        // Set up the renderer, enabling antialiasing and transparency.
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Add the AR button to start an AR session.
        document.body.appendChild(
          ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] })
        );

        // === Lighting Setup ===
        // HemisphereLight simulates ambient light coming from the sky.
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);

        // === Cube (Ghost Cat Placeholder) Setup ===
        // Create a simple cube; initially hidden until placed.
        const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshStandardMaterial({ color: 0xff00ff });
        cube = new THREE.Mesh(geometry, material);
        cube.visible = false;
        scene.add(cube);

        // === Spatial Audio Setup ===
        // Attach an AudioListener to the camera so sound is spatial.
        const listener = new THREE.AudioListener();
        camera.add(listener);

        // Create PositionalAudio and load the sound.
        sound = new THREE.PositionalAudio(listener);
        const audioLoader = new THREE.AudioLoader();
        audioLoader.load('purr.mp3', function (buffer) {
          sound.setBuffer(buffer);
          sound.setRefDistance(0.5);
          sound.setLoop(true);
          sound.setVolume(0.5);
        });
        cube.add(sound);

        // === Controller Setup for Interaction ===
        // Get the AR controller and add it to the scene.
        let controller = renderer.xr.getController(0);
        scene.add(controller);
        controller.addEventListener('select', () => {
          if (reticle.visible) {
            cube.position.setFromMatrixPosition(reticle.matrix);
            cube.visible = true;
            if (!sound.isPlaying) {
              sound.play();
            }
          }
        });

        // === Reticle Setup for Surface Detection ===
        // Create a reticle (a green ring) to indicate where the cube will be placed.
        const reticleGeometry = new THREE.RingGeometry(0.05, 0.06, 32).rotateX(-Math.PI / 2);
        const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // === Hit Test Setup ===
        let hitTestSource = null;
        // When the AR session starts, set up hit testing.
        renderer.xr.addEventListener('sessionstart', async () => {
          const session = renderer.xr.getSession();
          const viewerSpace = await session.requestReferenceSpace('viewer');
          hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
        });

        // Animation loop
        renderer.setAnimationLoop((timestamp, frame) => {
          if (frame && hitTestSource) {
            const referenceSpace = renderer.xr.getReferenceSpace();
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const pose = hit.getPose(referenceSpace);
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
          renderer.render(scene, camera);
        });
      }

      // Update camera and renderer on window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    </script>
  </body>
</html>
